<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Court Kings</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #222;
  touch-action: none;
}
canvas {
  display: block;
  margin: 0 auto;
  background: #4CAF50;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

const keys = {};
const players = [];
const ball = { x: width/2, y: height/2, radius: 12, heldBy: null, vx: 0, vy: 0, dribbleOffset: 0 };
let shieldActive = false;
let shieldTimer = 0;

const hoop = { x: width-150, y: height/2-50, width: 10, height: 100 };
const playerImage = new Image();
playerImage.src = 'player.png'; // single player image, transparent background

class Player {
  constructor(x, y, isAI=false, ability=null) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.width = 50;
    this.height = 100;
    this.onGround = true;
    this.isAI = isAI;
    this.ability = ability;
    this.jumpCooldown = 0;
    this.shootCooldown = 0;
    this.abilityCooldown = 0;
    this.bobOffset = 0;
    this.jumpPressed = false;
    this.animFrame = 0;
    this.facingRight = true;
  }

  update() {
    if (this.isAI) this.aiBehavior();

    this.x += this.vx;
    this.y += this.vy;

    if (this.vx > 0) this.facingRight = true;
    else if (this.vx < 0) this.facingRight = false;

    if (!this.onGround) this.vy += 0.8;

    if (this.y + this.height >= height-50) {
      this.y = height-50-this.height;
      if (!this.onGround && this.jumpPressed) {
        if (!this.isAI) releaseBall(this, 0.5); // smooth landing release for user
        this.jumpPressed = false;
      }
      this.onGround = true;
      this.vy = 0;
    } else this.onGround = false;

    // Animate running legs
    if (this.vx !== 0) this.animFrame = (this.animFrame + 0.2) % 4;
    else this.animFrame = 0;

    // Ball follows player
    if (ball.heldBy === this) {
      ball.x = this.x + this.width/2;
      ball.y = this.y + this.height/2 - ball.dribbleOffset;
      ball.dribbleOffset = (this.vx !== 0 || !this.onGround) ? Math.abs(Math.sin(Date.now()/100)*10) : 0;
    }
  }

  draw() {
    // Draw player rectangle as placeholder
    ctx.save();
    ctx.translate(this.x + this.width/2, this.y + this.height/2);
    ctx.scale(this.facingRight ? 1 : -1,1);
    ctx.drawImage(playerImage, -this.width/2, -this.height/2, this.width, this.height);
    ctx.restore();

    // Running leg animation (simple)
    if (this.vx !== 0) {
      ctx.strokeStyle='black';
      ctx.lineWidth=4;
      ctx.beginPath();
      let legOffset = Math.sin(this.animFrame*Math.PI/2)*10;
      ctx.moveTo(this.x + this.width/2, this.y + this.height);
      ctx.lineTo(this.x + this.width/2 + legOffset, this.y + this.height + 20);
      ctx.stroke();
    }
  }

  aiBehavior() {
    if (!ball.heldBy) {
      this.vx = ball.x < this.x ? -3 : 3;
    } else if (ball.heldBy !== this) {
      this.vx = ball.heldBy.x < this.x ? -3 : 3;
      if (Math.abs(this.x - ball.heldBy.x) < 50 && this.onGround && Math.random() < 0.01) {
        this.vy = -15;
        this.onGround = false;
      }
    } else {
      this.vx = 0;
      if (Math.abs(this.x - hoop.x) < 50 && this.onGround) shootBall(this);
      if (this.ability && this.abilityCooldown <= 0 && Math.random()<0.002) activateAbility(this);
    }
  }
}

function releaseBall(player, accuracy=1) {
  ball.heldBy = null;
  let dx = hoop.x - player.x;
  let dy = hoop.y - player.y;
  let dist = Math.sqrt(dx*dx + dy*dy);
  let power = 12 * accuracy;
  ball.vx = dx/dist*power;
  ball.vy = dy/dist*power;
}

function shootBall(player) {
  if (ball.heldBy !== player) return;
  ball.heldBy = null;
  let dx = hoop.x - player.x;
  let dy = hoop.y - player.y;
  let dist = Math.sqrt(dx*dx + dy*dy);
  let chance = dist < 200 ? 0.8 : 0.6;
  ball.vx = dx/dist*12*chance;
  ball.vy = dy/dist*12*chance;
}

function activateAbility(player) {
  if (!player.ability || player.abilityCooldown > 0) return;

  if (player.ability === 'mega') {
    let startY = player.y;
    let targetY = hoop.y - 50;
    let step = () => {
      if (player.y > targetY) {
        player.y -= 15;
        ball.x = player.x + player.width/2;
        ball.y = player.y + player.height/2;
        requestAnimationFrame(step);
      } else {
        releaseBall(player,1);
      }
    };
    step();
  } else if (player.ability === 'shield') {
    shieldActive = true;
    shieldTimer = 200;
  } else if (player.ability === 'alley') {
    let startY = player.y;
    let targetY = hoop.y - 100;
    let step = () => {
      if (player.y > targetY) {
        player.y -= 20;
        ball.x = player.x + player.width/2;
        ball.y = player.y + player.height/2;
        requestAnimationFrame(step);
      } else {
        releaseBall(player,1);
      }
    };
    step();
  }

  player.abilityCooldown = 300;
}

// Input
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

// Touch for mobile
let touchX = null;
canvas.addEventListener('touchstart', e => touchX = e.touches[0].clientX);
canvas.addEventListener('touchmove', e => {
  let dx = e.touches[0].clientX - touchX;
  keys['ArrowRight'] = dx > 10;
  keys['ArrowLeft'] = dx < -10;
});
canvas.addEventListener('touchend', e => keys['ArrowRight'] = keys['ArrowLeft'] = false);

// Players
players.push(new Player(100, height-150, false, 'mega')); // user has mega dunk
players.push(new Player(width-200, height-150, true, 'shield')); // AI has shield

function gameLoop() {
  ctx.clearRect(0, 0, width, height);

  let user = players[0];
  user.vx = keys['ArrowRight'] ? 5 : keys['ArrowLeft'] ? -5 : 0;

  if (keys['ArrowUp'] && user.onGround && user.jumpCooldown<=0) {
    user.vy = -15;
    user.onGround = false;
    user.jumpPressed = true;
    user.jumpCooldown = 20;
  }
  if (keys['x']) shootBall(user);
  if (keys['z']) activateAbility(user);

  user.jumpCooldown = Math.max(0, user.jumpCooldown-1);
  user.abilityCooldown = Math.max(0, user.abilityCooldown-1);

  for (let p of players) p.update();

  // Ball physics
  if (!ball.heldBy) {
    if (!shieldActive) ball.vy += 0.5;
    ball.x += ball.vx;
    ball.y += ball.vy;

    if (ball.y + ball.radius > height-50) {
      ball.y = height-50-ball.radius;
      ball.vy *= -0.5;
      if (Math.abs(ball.vy)<1) ball.vy = 0;
    }

    if (!shieldActive &&
        ball.x + ball.radius > hoop.x && ball.x - ball.radius < hoop.x+hoop.width &&
        ball.y + ball.radius > hoop.y && ball.y - ball.radius < hoop.y+hoop.height) {
      ball.heldBy = null;
      ball.x = width/2;
      ball.y = height/2;
      ball.vx = 0;
      ball.vy = 0;
      console.log("SCORE!");
    }
  }

  // Shield
  if (shieldActive) {
    shieldTimer--;
    if (shieldTimer<=0) shieldActive=false;
    ctx.fillStyle='rgba(0,0,255,0.5)';
    ctx.fillRect(hoop.x-5, hoop.y-5, hoop.width+10, hoop.height+10);
  }

  // Hoop
  ctx.fillStyle='orange';
  ctx.fillRect(hoop.x, hoop.y, hoop.width, hoop.height);

  // Ball
  ctx.fillStyle='yellow';
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
  ctx.fill();

  // Players
  for (let p of players) p.draw();

  requestAnimationFrame(gameLoop);
}

gameLoop();

// Fullscreen toggle
function toggleFullscreen() {
  if (!document.fullscreenElement) canvas.requestFullscreen();
  else document.exitFullscreen();
}
document.addEventListener('keydown', e => { if(e.key==='f') toggleFullscreen(); });

// Resize
window.addEventListener('resize', () => {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
  hoop.x = width-150;
  hoop.y = height/2-50;
});
</script>
</body>
</html>
